// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "Dielectric.hpp"

#include "Colour.hpp"
#include "Hittable.hpp"
#include "Vec3.hpp"

namespace rt::material {

using colour::Colour;
using hittable::HitRecord;
using ray::Ray;

/// Determine if an incidence ray is scattered when it hits a dielectric material
/// \param[in] rayIn The incidence ray
/// \param[in] record A record of how the incidence ray interacted with the dielectric surface
/// \param[out] attenuation How much the reflected ray is attenuated, if scattered
/// \param[out] scattered The reflected ray, which might be scattered
/// \returns True if the incidence ray is scattered, and false otherwise
bool Dielectric::scatter(Ray const& rayIn, HitRecord const& record, Colour& attenuation, Ray& scattered) const noexcept
{
  attenuation = Colour(1.0, 1.0, 1.0);
  double const refractionRatio = record.frontFace ? (1.0 / m_refractiveIndex) : m_refractiveIndex;

  auto const unitDirection = vec3::getUnitVector(rayIn.getDirection());
  double const cosTheta = std::fmin(vec3::getDotProduct(-unitDirection, record.normal), 1.0);
  double const sinTheta = std::sqrt(1.0 - cosTheta * cosTheta);

  bool const cannotRefract = (refractionRatio * sinTheta) > 1.0;
  auto direction = vec3::Vec3();

  if (cannotRefract) {
    direction = vec3::getReflectedRay(unitDirection, record.normal);
  }
  else {
    direction = vec3::getRefractedRay(unitDirection, record.normal, refractionRatio);
  }

  scattered = Ray(record.point, direction);

  return true;
}

}   // namespace rt::material
