// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "Vec3.hpp"

#include "Utilities.hpp"
#include <cmath>

namespace rt::vec3 {

/// Determine if this vector is very close to zero in all its dimensions
/// \returns True if the vector is very close to zero in all dimensions, false otherwise
bool Vec3::nearZero() const noexcept
{
  static constexpr auto s = 1e-8;
  return ((std::fabs(e[0]) < s) and (std::fabs(e[1]) < s) and std::fabs(e[2]) < s);
}

/// Get the vector of the direction of the refracted ray
/// \param[in] incidentRay The ray of incidence
/// \param[in] normal The normal
/// \param[in] etaIOverEtaT The ratio of the refractive indices of the material and its surrounding medium
/// \returns A Vec3 instance representing the direction of the refracted ray
Vec3 getRefractedRay(Vec3 const& incidentRay, Vec3 const& normal, double etaIOverEtaT) noexcept
{
  auto const cosTheta = std::fmin(getDotProduct(-incidentRay, normal), 1.0);
  auto const rOutPerp = etaIOverEtaT * (incidentRay + cosTheta * normal);
  auto const rOutParallel = -std::sqrt(std::fabs(1.0 - rOutPerp.lengthSquared())) * normal;

  return rOutPerp + rOutParallel;
}

/// Get a Vec3 with all coordinates randomly generated and in the range [0, 1)
/// \returns A Vec3 with all coordinates randomly generated and in the range [0, 1)
Vec3 Vec3::createRandomVec()
{
  return Vec3(getRandomDouble(), getRandomDouble(), getRandomDouble());
}

/// Get a Vec3 with all coordinates randomly generated and in the range [min, max)
/// \returns A Vec3 with all coordinates randomly generated and in the range [min, max)
Vec3 Vec3::createRandomVecInRange(double min, double max)
{
  return Vec3(getRandomDoubleInRange(min, max), getRandomDoubleInRange(min, max), getRandomDoubleInRange(min, max));
}

/// Get a point (Vec3) that lies in a sphere of unit radius
/// \returns A point (Vec3) that lies in a sphere of unit radius
Vec3 getRandomVecInUnitSphere()
{
  while (true) {
    auto const point = Vec3::createRandomVecInRange(-1, 1);

    if (point.lengthSquared() >= 1) {
      continue;
    }
    else {
      return point;
    }
  }
}

/// Get a random unit vector in a unit sphere
/// \returns A random unit vector in a unit sphere
Vec3 getRandomUnitVector()
{
  return getUnitVector(getRandomVecInUnitSphere());
}

/// Generate a random vector in a unit disk
/// \returns A random vector in a unit disk
Vec3 getRandomVecInUnitDisk()
{
  while (true) {
    auto p = Vec3(getRandomDoubleInRange(-1, 1), getRandomDoubleInRange(-1, 1), 0);

    if (p.lengthSquared() >= 1) {
      continue;
    }

    return p;
  }
}

}   // namespace rt::vec3
